WeftEnd Alpha Update (Windows Shell + Trust Hardening)
Date: 2026-02-13
Scope: Deterministic artifact intake, baseline/compare workflows, operator-facing report cards, and Windows shell reliability hardening.
Liability scope: WeftEnd is an evidence and change-tracking engine, not a malware oracle or compliance guarantee.

Included
- 360 commit gate added:
- `npm run verify:360` now performs compile/test/proofcheck + deterministic replay + privacy lint + compare smoke.
- Gate now always writes evidence artifacts (`verify_360_receipt.json` and `verify_360_report.txt`) for PASS/PARTIAL/FAIL outcomes.
- Host precondition misses are explicit PARTIAL/SKIP evidence, not silent no-output aborts.
- Gate enforces docs/update discipline: code changes without operator-facing doc updates fail with `VERIFY360_DOC_SYNC_MISSING`.
- Gate now uses explicit state progression and two-phase output finalize (`stage -> finalize`) with `verify_360_output_manifest.json`.
- Safe-run now enforces a non-blocking evidence corridor check before completion:
- Expected receipt artifacts are verified for presence and digest consistency.
- Pre-existing/stale unmanaged output files anywhere under the run out-root are flagged as orphan evidence.
- Analysis still completes; warnings are recorded deterministically in `operator_receipt.json` (`SAFE_RUN_EVIDENCE_*` codes).
- Added explicit smoke-test coverage for root-level stale output detection under the same non-blocking evidence-corridor behavior.
- `operator_receipt.json` now includes additive digest links for `weftend/README.txt` and run sub-receipts (`analysis/*`, `host/*`) to strengthen evidence-chain traceability.
- Universal artifact adapter expansion (analysis-only, deterministic, fail-closed):
- New safe-run adapter flags: `--adapter auto|none|archive|package|extension|iac|cicd|document|container|image|scm|signature`
- Optional repeatable plugin flag: `--enable-plugin <name>` (explicit local plugin use only)
- New adapter discovery command: `weftend adapter list`
- New adapter maintenance/health command: `weftend adapter doctor`
- Added readable doctor mode: `weftend adapter doctor --text` (deterministic local guidance, no auto-install/network).
- Added policy writer mode: `weftend adapter doctor --write-policy <path> [--include-missing-plugins]`.
- Adapter maintenance gate added (operator-controlled, fail-closed):
- `WEFTEND_ADAPTER_DISABLE=<adapter[,adapter...]>` disables selected adapter lanes without removing code.
- Optional file policy path: `WEFTEND_ADAPTER_DISABLE_FILE=<path-to-json>` with `{"disabledAdapters":[...]}`.
- Added maintenance policy template and reference docs:
- `policies/adapter_maintenance.example.json`
- `docs/ADAPTER_MAINTENANCE_POLICY.md`
- Unreadable maintenance policy files now surface deterministic file reason code details (`ADAPTER_POLICY_FILE_UNREADABLE`) through doctor and fail-closed adapter runs.
- Disabled adapter lanes fail closed with `ADAPTER_TEMPORARILY_UNAVAILABLE` and `ADAPTER_DISABLED_BY_POLICY`.
- Invalid disable-policy tokens fail closed with `ADAPTER_POLICY_INVALID`.
- Adapter maintenance/policy fail-closed paths now still write deterministic safe-run evidence artifacts (`safe_run_receipt.json`, `operator_receipt.json`, and analysis receipts) before returning precondition exit code.
- `container scan` fail-closed preconditions now also write deterministic evidence artifacts (`safe_run_receipt.json` and `operator_receipt.json`) before returning exit 40.
- `container scan` now honors adapter maintenance policy (`WEFTEND_ADAPTER_DISABLE` / `WEFTEND_ADAPTER_DISABLE_FILE`) for `container` lane control.
- Additive receipt/summary surface:
- `safe_run_receipt.json` optional `adapter` metadata block
- `contentSummary.adapterSignals` optional deterministic adapter signal block
- Optional adapter artifacts in run output:
- `analysis/adapter_summary_v0.json`
- `analysis/adapter_findings_v0.json`
- Package/extension ZIP metadata extraction deepened for deterministic manifest signals:
- `.msix/.nupkg/.whl/.jar` manifest text hints are now extracted from ZIP entries (bounded, analysis-only).
- `.crx/.vsix` now parse `manifest.json` when present in ZIP payloads (permissions/content scripts/update URL domain hints).
- `.xpi` extension bundles are now supported through the same deterministic ZIP-manifest path.
- `.crx` strict route now validates CRX wrapper header and embedded ZIP payload before manifest analysis, failing closed on malformed CRX payloads.
- Extension strict route now fails closed on partial ZIP metadata even when `manifest.json` is present, preventing mixed valid/corrupt extension package acceptance.
- Extension strict route now requires baseline manifest core fields (`manifest_version`, `name`, `version`) for explicit extension analysis, preventing empty/placeholder manifests from passing.
- Extension strict route now requires canonical root-path `manifest.json` presence and fails closed on nested-only manifest paths or duplicate root `manifest.json` entries.
- Extension strict route now requires non-ambiguous extension package entry-path sets, preventing duplicate or case-colliding package paths from passing explicit extension analysis.
- Extension strict route now enforces the same non-ambiguous entry-path set rule for unpacked extension inputs, preventing duplicate or case-colliding directory paths from passing explicit extension analysis.
- Linux package coverage added to package adapter:
- `.deb` now parses deterministic AR entry metadata (bounded, no extraction/exec).
- `.rpm` now captures deterministic lead/header/script/signing hint counters from local bytes only.
- `.appimage` now captures deterministic ELF/runtime header hints (analysis-only; execution withheld).
- Package strict route for `.appimage` now requires valid ELF ident fields (class/data/version) in addition to ELF magic/runtime marker bytes, preventing malformed ELF-ident placeholders from passing explicit package routing.
- Package strict route now requires minimum structural byte-size evidence for `.nupkg` and `.jar` beyond manifest-only ZIP structure, preventing tiny synthetic placeholders from passing explicit package routing.
- Package strict route now requires `.whl` explicit structure evidence (`METADATA`, `WHEEL`, and `RECORD` in `.dist-info`), preventing partial wheel metadata placeholders from passing explicit package routing.
- Package strict route now requires `.msix` explicit OPC structure evidence (`AppxManifest`/`AppxBundleManifest` plus `[Content_Types].xml`) before size-floor checks are considered.
- Package strict route now requires minimum structural byte-size evidence for `.msix` beyond manifest-only ZIP structure, preventing tiny synthetic placeholders from passing explicit package routing.
- Package strict route now requires minimum structural byte-size evidence for `.deb` beyond required AR entry names, preventing tiny synthetic placeholders from passing explicit package routing.
- Package strict route now requires non-ambiguous Debian required-entry cardinality, preventing duplicate required `.deb` structure entries from passing strict package routing.
- Package strict compressed-tar plugin route now requires non-ambiguous archive entry paths from plugin listing output, preventing duplicate or case-colliding path ambiguity from passing explicit package archive routing.
- Package plugin applicability now includes package adapter routes, so `--enable-plugin tar` is accepted for compressed package tar formats and still fails closed as `ADAPTER_PLUGIN_UNUSED` on non-applicable package formats.
- Added adapter and CLI regression coverage for package tar-plugin routing, including accepted plugin path (`mode=plugin`) and non-applicable plugin rejection (`ADAPTER_PLUGIN_UNUSED`).
- Package strict route now requires minimum structural byte-size evidence for `.exe` beyond valid PE header bytes, preventing tiny synthetic placeholders from passing explicit package routing.
- Package strict route now requires minimum structural byte-size evidence for `.msi` beyond valid CFB header bytes, preventing tiny synthetic placeholders from passing explicit package routing.
- Package strict route now requires minimum structural byte-size evidence for `.appimage` beyond valid runtime marker bytes, preventing tiny synthetic placeholders from passing explicit package routing.
- Package strict route now requires minimum structural byte-size evidence for `.rpm` beyond lead/header marker bytes, preventing tiny synthetic placeholders from passing explicit package routing.
- Package strict route now fails closed on partial ZIP/AR metadata even when required structure markers are present, preventing mixed valid/corrupt package acceptance.
- Package strict route now requires canonical ZIP marker paths for `.msix/.nupkg/.whl` structure checks, preventing nested lookalike marker paths from passing explicit package routing.
- Package strict route now requires unique required-marker cardinality for `.msix/.nupkg/.whl/.jar` ZIP structures, preventing duplicate/ambiguous required-marker sets from passing explicit package routing.
- Package strict route now evaluates raw ZIP entry catalogs for required-marker cardinality, preventing duplicate same-path required markers from being hidden by ZIP-entry deduplication in explicit package routing.
- Package strict route now requires non-ambiguous package entry-path sets (duplicate or case-colliding package entry paths fail strict routing), preventing ambiguous package archives from passing explicit package analysis.
- Archive/package tar coverage expanded:
- `.tar.bz2/.tar.xz/.txz` now follow explicit tar-plugin, fail-closed handling in archive/package lanes.
- `.tbz2/.tbz` aliases now normalize to `.tar.bz2` for deterministic package/archive adapter routing and plugin gating.
- Added adapter and CLI regression coverage for `.tbz2/.tbz` archive/package fail-closed plugin-required behavior.
- `weftend adapter list` now advertises `.tbz2/.tbz` aliases for archive/package lanes to match actual deterministic routing support.
- Explicit `.tar` archive analysis now validates header checksum and octal size fields and fails closed on partial metadata even when earlier entries parsed, preventing mixed valid/corrupt tar acceptance.
- Explicit `.zip` archive analysis now validates central-directory integrity in strict route and fails closed on partial metadata even when earlier entries parsed, preventing mixed valid/corrupt ZIP acceptance.
- Explicit `.zip` and `.tar` strict archive routes now require non-ambiguous entry paths, preventing duplicate or case-colliding entry-path ambiguity from passing strict archive routing.
- Strict plugin archive routes (`.tgz/.tar.gz/.txz/.tar.xz/.7z`) now enforce non-ambiguous entry-path sets from plugin listing output, preventing duplicate or case-colliding path ambiguity from passing explicit plugin-backed archive routing.
- macOS installer coverage added to package adapter:
- `.pkg` now captures deterministic XAR header and script/permission hint counters.
- `.dmg` now captures deterministic trailer marker hints (`koly`) without mounting.
- Package strict route now requires minimum structural byte-size evidence for `.pkg` and `.dmg` beyond valid header/trailer markers, preventing tiny synthetic placeholders from passing explicit package routing.
- Document adapter deepened for `.docm/.xlsm`:
- ZIP structure + relationships are inspected deterministically for macro/embed/external-link indicators.
- Document strict route now fails closed on partial OOXML ZIP metadata even when structural markers are present, preventing mixed valid/corrupt office-document acceptance.
- Document strict route now requires both PDF header and EOF marker evidence for explicit `.pdf` analysis, preventing header-only placeholder inputs from passing strict document routing.
- Document strict route now requires PDF object-syntax evidence (`<obj> <gen> obj`) plus structural marker evidence (`xref`/catalog/trailer) for explicit `.pdf` analysis, preventing loose-token placeholder inputs from passing strict document routing.
- Document strict route now requires PDF `startxref` marker evidence for explicit `.pdf` analysis, preventing object+trailer placeholder inputs from passing strict document routing.
- Document strict route now requires OOXML primary part evidence for explicit office-document analysis (`word/document.xml` for `.docm`, `xl/workbook.xml` for `.xlsm`), preventing marker-only office ZIP shells from passing strict routing.
- Added strict-route regression coverage for both `.docm` and `.xlsm` missing-primary-part cases to pin fail-closed behavior in adapter and CLI smoke suites.
- Document strict route now requires unique required-marker cardinality for OOXML inputs (`[Content_Types].xml` and the primary-part path must each appear exactly once), preventing duplicate/ambiguous OOXML marker sets from passing strict routing.
- Document strict route now requires non-ambiguous OOXML entry-path sets, preventing duplicate or case-colliding OOXML package paths from passing explicit document analysis.
- Document strict route now requires type-specific OOXML relationship evidence (`word/_rels/document.xml.rels` for `.docm`, `xl/_rels/workbook.xml.rels` for `.xlsm`, or root `_rels/.rels`), preventing cross-type relationship markers from passing strict routing.
- Document strict route now requires non-ambiguous OOXML relationship marker cardinality (duplicate root/type-specific relationship markers fail closed), preventing duplicate relationship-marker ambiguity from passing strict routing.
- Document strict route now requires a strict RTF prolog (`{\\rtf1`), baseline control-word evidence (`\\ansi`/`\\deff`), and closing-brace evidence for explicit `.rtf` analysis, preventing partial/plaintext placeholders from passing strict document routing.
- Document strict route now requires minimum CHM structural header evidence (including header-length sanity) for explicit `.chm` analysis, preventing tiny header-only placeholders from passing strict document routing.
- IaC/CI adapter extraction deepened:
- Deterministic action reference parsing now distinguishes pinned commit/digest refs from unpinned refs.
- Remote module/source indicators and external runner signals are counted with structured counters in adapter summary output.
- CI/CD path hints and adapter discovery now explicitly include `.gitlab-ci.yaml` and `azure-pipelines*.yaml` alongside existing `.yml` patterns.
- IaC adapter discovery now explicitly includes `.template` to match implemented adapter routing coverage.
- Added explicit regression coverage for `.gitlab-ci.yaml` success and `azure-pipelines.yaml` path-hint-only fail-closed behavior in adapter/runtime and CLI smoke suites.
- Auto adapter CI/CD path hint matching is now canonical-name based (`.github/workflows/*.yml|*.yaml`, `.gitlab-ci.yml|.yaml`, `azure-pipelines*.yml|*.yaml`) to avoid backup/substring false positives forcing CICD route failures.
- Explicit `cicd` route now requires CI structure/signals (not filename/path hints alone), failing closed on path-hint-only placeholders.
- Adapter `auto` classification now treats CI structure/action references as CI evidence, so valid pinned workflows classify as `cicd` instead of falling back to `iac`.
- Explicit `iac` route now requires IaC structural signals; CI-style workflow content with generic secret terms no longer passes strict IaC routing.
- Explicit `iac` and `cicd` routes now require non-ambiguous entry-path sets, preventing duplicate or case-colliding directory paths from passing strict route analysis.
- Container adapter extraction deepened:
- OCI layout counts now include manifest and blob counts.
- Container tarball detection now recognizes Docker-style markers (`manifest.json` + `repositories`) and OCI tar markers (`oci-layout` + `index.json` + `blobs/sha256/*`) for local tar inputs.
- Explicit OCI layout route now fails closed when manifests exist but blob evidence is missing (`CONTAINER_LAYOUT_INVALID`), preventing partial container identity acceptance.
- Explicit OCI layout route now requires manifest digest references to resolve to blob entries, preventing unrelated blob padding from satisfying strict OCI layout evidence.
- Explicit OCI layout route now requires digest references for every manifest entry when manifests are present, preventing partial/digestless OCI manifest shells from passing strict layout routing.
- Explicit container route now fails closed when OCI index manifests shape is invalid and when container tar metadata is partial, preventing mixed valid/corrupt container acceptance.
- Explicit Docker-style tar route now requires at least one `layer.tar` entry when `manifest.json` and `repositories` markers are present, preventing placeholder tar marker shells from passing strict container routing.
- Explicit Docker-style tar route now also requires valid `manifest.json` and `repositories` JSON payload structure, and requires all manifest layer references to resolve to tar entries.
- Explicit Docker-style tar route now requires at least one repository/tag mapping in `repositories` JSON, preventing non-empty but non-usable repository shells from passing strict routing.
- Explicit Docker-style tar route now requires all manifest config references to resolve to tar entries, preventing partial config payload shells from passing strict routing.
- Explicit Docker-style tar route now requires non-ambiguous config/layer reference resolution, preventing duplicate referenced tar paths from passing strict docker tar routing.
- Explicit container tar strict route now requires non-ambiguous tar entry-path sets, preventing duplicate or case-colliding tar entry paths from passing explicit container tar analysis.
- Explicit container directory strict route now requires non-ambiguous entry-path sets, preventing duplicate or case-colliding directory paths from passing explicit container analysis.
- Explicit Docker-style tar route now requires canonical root marker paths (`manifest.json`, `repositories`), preventing nested lookalike marker paths from satisfying strict Docker tar routing.
- Explicit Docker/OCI tar strict routes now require unique canonical root marker entries, preventing duplicate marker-entry ambiguity from satisfying strict tar routing.
- Explicit Docker-style tar route now requires each manifest entry to include config and layer references, preventing mixed complete/incomplete manifest arrays from passing strict routing.
- Explicit container tar classification now uses tar entry markers only (not filename hints), preventing marker-looking tar filenames from passing strict container routing.
- Explicit OCI tar strict route now requires manifest digest references to resolve to blob entries, preventing unrelated blob padding from satisfying strict OCI tar evidence.
- Explicit OCI tar strict route now requires non-ambiguous digest resolution to blob paths, preventing duplicate referenced blob paths from passing strict OCI tar routing.
- Explicit OCI tar strict route now requires digest references for every manifest entry when manifests are present, preventing partial/digestless OCI tar manifest shells from passing strict routing.
- Explicit OCI tar strict route now requires canonical root marker paths (`oci-layout`, `index.json`), preventing nested lookalike marker paths from satisfying strict OCI tar routing.
- Added regression coverage for OCI layout/tar digest-required strict paths (missing digest refs and digest-mismatch scenarios) in adapter and CLI smoke suites.
- Explicit compose route now fails closed when service placeholders exist without valid indented service entries or without `image`/`build` evidence, while still allowing build-only compose service definitions.
- Explicit compose route now requires `image`/`build` evidence to be inside a service block, preventing out-of-service image placeholders from passing strict compose routing.
- Explicit SBOM route now fails closed when package/component evidence is empty, preventing empty SBOM shells from passing strict container SBOM analysis.
- Explicit SBOM route now requires meaningful package/component identity evidence (`name`, `purl`, `SPDXID`, or `bom-ref`), preventing empty object shells from passing strict SBOM analysis.
- SBOM JSON parsing now emits bounded package/component counts when present.
- Signature/cert adapter extraction deepened:
- Deterministic PEM block counting for certificate/PKCS7/signature material.
- Strict PEM envelope evidence now requires decodable DER-like payload bytes; malformed PEM payload wrappers no longer pass explicit signature routing.
- Strict signature routing now enforces extension-compatible envelope evidence (`.p7b` and `.sig` no longer pass with certificate-only PEM envelopes).
- Binary OID hint counts added for CMS signedData and timestamp EKU indicators.
- DER certificate fallback in explicit `.cer/.crt` strict mode now requires X.509 name OID evidence (`2.5.4.*`), preventing generic large DER blobs from passing as certificate evidence.
- Explicit signature route now requires real envelope/OID/DER evidence; text-only timestamp/chain hints no longer satisfy strict signature validity checks.
- Explicit signature route now rejects tiny generic DER blobs as insufficient strict signature evidence.
- Generic DER fallback in strict signature mode is now limited to certificate extensions (`.cer/.crt`), so `.sig` requires explicit signature-envelope/OID evidence.
- SCM/source evidence adapter extraction deepened:
- Deterministic repo counters now include tree entry count, branch/tag ref counts, detached HEAD indicator, and working-tree entry count.
- SCM adapter now emits deterministic worktree state evidence (staged/unstaged/untracked counts) and `SCM_WORKTREE_DIRTY` when local repo state is dirty.
- SCM fallback hardening:
- When `git` commands are unavailable/failing, adapter now parses native `.git` reference material (`HEAD`, loose refs, packed-refs) deterministically for source evidence.
- SCM strict route now fails closed on partial git/native-ref/status metadata, preventing partial SCM evidence from being treated as complete explicit SCM analysis.
- SCM strict route now requires non-ambiguous worktree entry-path sets, preventing duplicate or case-colliding worktree paths from passing explicit SCM analysis.
- Image adapter extraction deepened:
- Deterministic header evidence now includes ISO PVD, VHD footer, VHDX signature, QCOW2 magic/version, and VMDK descriptor/sparse-magic hints.
- Explicit ISO route now requires both primary volume descriptor and descriptor-set terminator evidence, preventing PVD-only placeholders from passing strict image routing.
- Explicit image route now requires minimum structural byte-size evidence for `qcow2` and `vhdx` beyond magic/signature bytes, preventing tiny signature-only files from passing strict image analysis.
- Explicit image route now requires minimum structural byte-size evidence for `vhd` beyond footer marker bytes, preventing tiny footer-only files from passing strict image analysis.
- Explicit image route now requires minimum descriptor size for descriptor-only `vmdk` analysis, preventing tiny placeholder descriptors from passing strict image routing.
- Package/installer signing evidence deepened:
- Deterministic local signing hints now include PE cert-table presence for `.exe` and signature-entry hints for `.msix/.nupkg/.whl/.jar`.
- New package reason code support: `PACKAGE_SIGNING_INFO_PRESENT` alongside existing unavailable paths.
- Container scan now emits adapter metadata/signals plus adapter artifacts using the same deterministic contract as safe-run adapters.
- Container scan evidence remains local-only inspect data and excludes unstable fields (timestamps/raw env/path values).
- Container scan now requires immutable image digest refs (`name@sha256:...` or `sha256:...`) and fails closed on mutable tag refs.
- Container scan now fails closed when Docker inspect resolves to a digest that does not match the immutable input digest ref.
- Privacy lint coverage now includes wildcard `analysis/*.json` artifacts so new adapter JSON outputs cannot bypass privacy scanning by filename drift.
- Privacy lint coverage now includes wildcard `analysis/*.txt` artifacts for the same anti-bypass guarantee on adapter text outputs.
- Wave coverage now includes:
- Wave 1: archives, packages/installers, extensions
- Wave 2 baseline: IaC/CICD and document risk signal extraction
- Wave 3 baseline: container/source/signature/image evidence lanes
- Core/runtime trust hardening sweep applied in release scope (digest/trust/runtime path updates, host verification flow updates, and aligned fixture/contract updates).
- Builder integration surface explicitly supported: `weftend export-json <outRoot> --format normalized_v0` emits deterministic `weftend.normalizedSummary/0` output for downstream tools (see docs/POWERED_BY_WEFTEND.md).
- Shortcut scan accuracy fix for .lnk targets: report and compare now resolve the actual target script/program instead of effectively classifying the shell host.
- Baseline decision flow hardening for CHANGED/BLOCKED runs in Launchpad paths (accept/decline prompt reliability and gating behavior).
- Native report viewer workflow is the default operator path; Notepad is no longer the primary report UX.
- Report viewer startup hardened: host console launches hidden while the report viewer opens in normal visible state for review.
- Launchpad History UX improvements: direct View Report action and keyboard open behavior (double-click/Enter).
- New bind/unbind right-click flow:
- Bind to WeftEnd and Unbind from WeftEnd verbs for files, shortcuts, and folders.
- .lnk rewrap mode preserves icon and stores an original shortcut backup for safe restoration.
- Legacy metadata compatibility fixes prevent stale-state and strict-mode unbind failures.
- Shell integration simplification: only WeftEnd Launchpad and WeftEnd Download shortcuts are installed by default.
- Structured report artifacts available for UI and automation:
- report_card_v0.json
- report_card.txt

Validation
- npm run compile --silent: pass
- node dist/src/tools/windows_shell_assets.test.js: pass
- node dist/src/tools/greenteam/release_artifacts_present.test.js: pass
- npm test: pass (on release hardening sweep state)

Not included
- Malware scoring or reputation.
- Cloud analysis or telemetry.
- Automatic execution of native binaries outside explicit gated flows.
- Automatic trust root generation.

Operator notes
- Standard and portable release zips each ship with a .sha256 file for verification.
- Use published release zips, not GitHub auto-generated source archives, for operator installs.
- STATUS SAME can occur after a changed run if that changed state was accepted as the current baseline.
- See docs/DISCLAIMER.md for legal scope and non-guarantees.
